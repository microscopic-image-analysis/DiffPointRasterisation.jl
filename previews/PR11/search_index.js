var documenterSearchIndex = {"docs":
[{"location":"batch/#Raster-a-single-point-cloud-to-a-batch-of-poses","page":"Batch of poses","title":"Raster a single point cloud to a batch of poses","text":"","category":"section"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"To make best use of the hardware it is advantageous to raster a batch of poses at once. On GPU hardware this is currently also the only supported mode.","category":"page"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"To raster a single point cloud to a batch of n images, all parameters except the point cloud should be provided as n-vectors.","category":"page"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"This is a more flexible interface than the often used array with trailing batch dimension, since it allows to pass in a batch of parameters that have a more structured type than a simple array (e.g. a vector of Rotation objects from Rotations.jl).","category":"page"},{"location":"batch/#Array-with-trailing-batch-dim-to-vec-of-array","page":"Batch of poses","title":"Array with trailing batch dim to vec of array","text":"","category":"section"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"If you have data in the array with trailing batch dimension format, it is straightforward (and quite cheap) to reinterpret it as a batch-vector of single parameters:","category":"page"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"julia> matrices = randn(2, 2, 3)  # batch of 3 2x2-matrices as 3d-array\n2×2×3 Array{Float64, 3}:\n[:, :, 1] =\n -0.947072  1.10155\n  0.328925  0.0957267\n\n[:, :, 2] =\n -1.14336   1.71218\n  0.277723  0.436665\n\n[:, :, 3] =\n -0.114541  -0.769275\n  0.321084  -0.215008\n\njulia> using StaticArrays\n\njulia> vec_of_matrices = reinterpret(reshape, SMatrix{2, 2, Float64, 4}, reshape(matrices, 4, :))\n3-element reinterpret(reshape, SMatrix{2, 2, Float64, 4}, ::Matrix{Float64}) with eltype SMatrix{2, 2, Float64, 4}:\n [-0.947072487060636 1.1015531033643386; 0.3289251820481776 0.0957267306067441]\n [-1.143363316882325 1.712179045069409; 0.27772320359678004 0.4366650562384542]\n [-0.11454148373779363 -0.7692750798350269; 0.32108447348937047 -0.21500805160408776]","category":"page"},{"location":"batch/#Pre-allocation-for-batched-pullback","page":"Batch of poses","title":"Pre-allocation for batched pullback","text":"","category":"section"},{"location":"batch/","page":"Batch of poses","title":"Batch of poses","text":"raster_pullback! can be optionally provided with pre-allocated arrays for its output. For these arrays the expected format is actually in the nd-array with trailing batch dimension format. The rationale behind this is that the algorithm works better on continuous blocks of memory, since atomic operations are required. ","category":"page"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = DiffPointRasterisation","category":"page"},{"location":"api/#Exported-functions","page":"API","title":"Exported functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DiffPointRasterisation]\nPrivate = false","category":"page"},{"location":"api/#DiffPointRasterisation.raster","page":"API","title":"DiffPointRasterisation.raster","text":"raster(grid_size, points, rotation, translation, [background, out_weight])\n\nInterpolate points (multi-) linearly into an Nd-array of size grid_size.\n\nBefore points are interpolated into the array, each point p is first transformed according to\n\nhatp = R p + t\n\nwith rotation R and translation t.\n\nPoints hatp that fall into the N-dimensional hypercube with edges spanning from (-1, 1) in each dimension, are interpolated into the output array.\n\nThe total weight of each point (out_weight * point_weight) is distributed onto the 2^N nearest pixels/voxels of the output array (according to the closeness of the voxel center to the coordinates of point hatp) via N-linear interpolation.\n\nArguments\n\ngrid_size: Tuple of integers defining the output dimensions\npoints::AbstractVector{<:AbstractVector}: A vector of same length vectors representing points\nrotation: Either a single matrix(-like object) or a vector of such, that linearly transform(s) points before rasterisation.\ntranslation: Either a single vector or a vector of such, that translates points after rotation. If rotation includes a projection, translation thus needs to have the same length as rotation * points[i].\nbackground: Either a single number or a vector of such.\nout_weight: Either a single number or a vector (one per image) of such.\npoint_weight: A vector of numbers (one per point).\n\nrotation, translation, background and out_weight can have an  additional \"batch\" dimension (by providing them as vectors of single parameters. The length of these vectors must be the same for all four arguments). In this case, the output array will have dimensionality +1 with an additional axis on last position corresponding to the number of elements in the batch. See Raster a single point cloud to a batch of poses for more details.\n\nSee also: raster!\n\n\n\n\n\n","category":"function"},{"location":"api/#DiffPointRasterisation.raster!","page":"API","title":"DiffPointRasterisation.raster!","text":"raster!(out, points, rotation, translation, [background, out_weight, point_weight])\n\nInterpolate points (multi-) linearly into the Nd-array out. In-place version of raster. See there for details.\n\n\n\n\n\n","category":"function"},{"location":"api/#DiffPointRasterisation.raster_pullback!","page":"API","title":"DiffPointRasterisation.raster_pullback!","text":"raster_pullback!(\n    ds_dout, args...;\n    [points, rotation, translation, background, out_weight, point_weight]\n)\n\nPullback for raster / raster!.\n\nTake as input ds_dout the sensitivity of some quantity (s for \"scalar\") to the output out of the function out = raster(grid_size, args...) (or out = raster!(out, args...)), as well as the exact same arguments args that were passed to raster/raster!, and return the sensitivities of s to the inputs args of the function raster/raster!.\n\nOptionally, pre-allocated output arrays for each input sensitivity can be specified as keyword arguments with the name of the original argument to raster as key, and a nd-array as value, where the n-th dimension is the batch dimension. For example to provide a pre-allocated array for the sensitivity of s to the translation argument of raster, do: sensitivities = raster_pullback!(ds_dout, args...; translation = [zeros(2) for _ in 1:8]) for 2-dimensional points and a batch size of 8. See also Raster a single point cloud to a batch of poses\n\n\n\n\n\n","category":"function"},{"location":"api/#Private-functions","page":"API","title":"Private functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [DiffPointRasterisation]\nPublic = false","category":"page"},{"location":"api/#DiffPointRasterisation.digitstuple-Union{Tuple{N}, Tuple{Any, Val{N}}, Tuple{Any, Val{N}, Any}} where N","page":"API","title":"DiffPointRasterisation.digitstuple","text":"digitstuple(k, Val(N))\n\nReturn a N-tuple containing the bit-representation of k\n\n\n\n\n\n","category":"method"},{"location":"api/#DiffPointRasterisation.reference_coordinate_and_deltas-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Any}} where T","page":"API","title":"DiffPointRasterisation.reference_coordinate_and_deltas","text":"reference_coordinate_and_deltas(point, rotation, origin, scale)\n\nReturn \n\nThe cartesian coordinate of the voxel of an N-dimensional rectangular  grid that is the one closest to the origin, out of the 2^N voxels that are next neighbours of the (N-dimensional) point\nA Nx2 array containing coordinate-wise distances of the scaled point to the voxel that is\nclosest to the origin (out of the 2^N next neighbors) in the first column\nfurthest from the origin (out of the 2^N next neighbors) in the second column.\n\nThe grid is implicitely assumed to discretize the hypercube ranging from (-1, 1) in each dimension. Before point is discretized into this grid, it is first translated by  -origin and then scaled by scale.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiffPointRasterisation.voxel_shifts-Union{Tuple{Val{N}}, Tuple{N}, Tuple{Val{N}, Any}} where N","page":"API","title":"DiffPointRasterisation.voxel_shifts","text":"voxel_shifts(Val(N), [int_type])\n\nEnumerate nearest neighbor coordinate shifts with respect to \"upper left\" voxel.\n\nFor a N-dimensional voxel grid, return a 2^N-tuple of N-tuples, where each element of the outer tuple is a cartesian coordinate shift from the \"upper left\" voxel.\n\n\n\n\n\n","category":"method"},{"location":"#DiffPointRasterisation","page":"Home","title":"DiffPointRasterisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Differentiable rasterisation of point clouds in julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffPointRasterisation.jl provides a rasterisation routine for arbitrary-dimensional point cloud data that is fully (auto-)differentiable. The implementation uses multiple threads on CPU or GPU hardware if available.","category":"page"},{"location":"#Rasterisation-interface","page":"Home","title":"Rasterisation interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The interface consists of a single function raster that accepts a point cloud (as a vector of m-dimensional vectors) and pose/projection parameters, (as well as optional weight and background parameters) and returns a n-dimensional (n <= m) array into which the points are rasterized, each point by default with a weight of 1 that is mulit-linearly interpolated into the neighboring grid cells.","category":"page"},{"location":"#Differentiability","page":"Home","title":"Differentiability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Both, an explicit function that calculates derivatives of raster, as well as an integration to common automatic differentiation libraries in julia are provided.","category":"page"},{"location":"#Automatic-differentiation-libraries","page":"Home","title":"Automatic differentiation libraries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rules for reverse-mode automatic differentiation libraries that are based on the ChainRules.jl ecosystem are provided via an extension package. So using raster(args...) in a program that uses any of the ChainRules-based reverse-mode autodiff libraries should just work™. Gradients with respect to all parameters (except grid_size) are supported.","category":"page"},{"location":"#Explicit-interface","page":"Home","title":"Explicit interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The explicit interface for calculating derivatives of raster with respect to its arguments again consists of a single function called raster_pullback!:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function raster_pullback!(ds_dout, raster_args...) takes as input the sensitivity of some scalar quantity to the output of raster(grid_size, raster_args...), ds_dout, and returns the sensitivity of said quantity to the input arguments raster_args of raster (hence the name pullback).","category":"page"}]
}
